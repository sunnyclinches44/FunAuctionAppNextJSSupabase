import { useState, useCallback, useRef } from 'react'
import { useSessionStore } from '@/store/useSessionStore'

export interface BiddingState {
  isPlacingBid: string | null
  showCustomInput: string | null
  customAmount: string
}

export function useBidding(sessionCode: string, deviceId: string) {
  const [biddingState, setBiddingState] = useState<BiddingState>({
    isPlacingBid: null,
    showCustomInput: null,
    customAmount: ''
  })

  // Track pending bids to prevent race conditions
  const pendingBidsRef = useRef<Set<string>>(new Set())
  
  const { placeBid: storePlaceBid, addOptimisticBid, revertOptimisticBid, undoBidAsync } = useSessionStore()

  const placeBid = useCallback(async (amount: number, participantId: string) => {
    if (!sessionCode || !deviceId) {
      console.error('Missing sessionCode or deviceId:', { sessionCode, deviceId })
      return false
    }

    // Prevent duplicate bids for the same participant
    if (pendingBidsRef.current.has(participantId)) {
      console.log('Bid already in progress for participant:', participantId)
      return false
    }

    console.log('Placing bid:', { amount, participantId, sessionCode, deviceId })
    
    // Add to pending bids to prevent race conditions
    pendingBidsRef.current.add(participantId)
    setBiddingState(prev => ({ ...prev, isPlacingBid: participantId }))
    
    // Optimistic update for immediate UI feedback
    addOptimisticBid(participantId, amount)
    
    try {
      const success = await storePlaceBid(sessionCode, deviceId, amount)
      console.log('Bid result:', success)

      if (!success) {
        // Revert optimistic update on failure
        revertOptimisticBid(participantId, amount)
        alert('Failed to place bid. Please try again.')
        return false
      }

      return true
    } catch (error) {
      console.error('Error placing bid:', error)
      // Revert optimistic update on error
      revertOptimisticBid(participantId, amount)
      alert('Failed to place bid. Please try again.')
      return false
    } finally {
      // Remove from pending bids
      pendingBidsRef.current.delete(participantId)
      setBiddingState(prev => ({ ...prev, isPlacingBid: null }))
    }
  }, [sessionCode, deviceId, storePlaceBid, addOptimisticBid, revertOptimisticBid])

  const placeCustomBid = useCallback(async (amount: number, participantId: string) => {
    if (!sessionCode || !deviceId) return false

    // Prevent duplicate bids for the same participant
    if (pendingBidsRef.current.has(participantId)) {
      console.log('Custom bid already in progress for participant:', participantId)
      return false
    }

    setBiddingState(prev => ({ ...prev, isPlacingBid: participantId }))
    
    // Add to pending bids
    pendingBidsRef.current.add(participantId)
    
    // Optimistic update
    addOptimisticBid(participantId, amount)
    
    try {
      const success = await storePlaceBid(sessionCode, deviceId, amount)

      if (!success) {
        // Revert optimistic update on failure
        revertOptimisticBid(participantId, amount)
        alert('Failed to place bid. Please try again.')
        return false
      }

      // Clear custom input on success
      setBiddingState(prev => ({ 
        ...prev, 
        showCustomInput: null, 
        customAmount: '',
        isPlacingBid: null 
      }))
      
      return true
    } catch (error) {
      console.error('Error placing custom bid:', error)
      // Revert optimistic update on error
      revertOptimisticBid(participantId, amount)
      alert('Failed to place bid. Please try again.')
      return false
    } finally {
      // Remove from pending bids
      pendingBidsRef.current.delete(participantId)
      setBiddingState(prev => ({ ...prev, isPlacingBid: null }))
    }
  }, [sessionCode, deviceId, storePlaceBid, addOptimisticBid, revertOptimisticBid])

  const setCustomInput = useCallback((participantId: string | null, amount: string = '') => {
    setBiddingState(prev => ({ 
      ...prev, 
      showCustomInput: participantId, 
      customAmount: amount 
    }))
  }, [])

  const updateCustomAmount = useCallback((amount: string) => {
    setBiddingState(prev => ({ ...prev, customAmount: amount }))
  }, [])

  // Check if a participant can bid (not currently bidding)
  const canBid = useCallback((participantId: string) => {
    return !pendingBidsRef.current.has(participantId) && biddingState.isPlacingBid !== participantId
  }, [biddingState.isPlacingBid])

  // Undo the last bid for a participant
  const undoBid = useCallback(async (participantId: string) => {
    if (!sessionCode || !deviceId) {
      console.error('Missing sessionCode or deviceId:', { sessionCode, deviceId })
      return false
    }

    // Prevent undo while bidding is in progress
    if (pendingBidsRef.current.has(participantId)) {
      console.log('Cannot undo while bid is in progress for participant:', participantId)
      return false
    }

    console.log('Undoing bid for participant:', participantId)
    
    try {
      // Call the database function to undo the bid
      const success = await undoBidAsync(sessionCode, deviceId)
      if (success) {
        console.log('Bid successfully undone in database')
      } else {
        console.error('Failed to undo bid in database')
        alert('Failed to undo bid. Please try again.')
      }
      return success
    } catch (error) {
      console.error('Error undoing bid:', error)
      alert('Failed to undo bid. Please try again.')
      return false
    }
  }, [sessionCode, deviceId, undoBidAsync])

  return {
    ...biddingState,
    placeBid,
    placeCustomBid,
    setCustomInput,
    updateCustomAmount,
    canBid,
    undoBid
  }
}
